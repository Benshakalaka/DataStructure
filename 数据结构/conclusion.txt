哈夫曼树
一些总结：
①
在哈夫曼编码过程中，首先先建立哈夫曼树，然后进行编码工作。  这里面涉及到一种遍历的方式（类似编码的第二种方式），在存储方式为孩子双亲二叉树的遍历算法中，可以通过设立一个变量有3中可能，分别 0，1，2。    0意味着往左，1意味着往右，2意味着此节点为根的树已经访问完毕。
②
越来越发现一个函数的实现基于两方面，首先就是算法的提出，继而才是算法的实现。算法的提出可能就是从某个点出发，接着发散，从而完成整个过程。  如这里编码的第二种方式考虑的三种情况0，1，2 ；再如平衡二叉树中的平衡因子可能值，可能情况从而有了整个算法。  所以在创造或是回忆算法时候，注意分情况，不同情况不同实现，说不定整个算法就跃然纸上。

图-》森林
总结：
有个小技巧我觉得很不错：
			if(!T)
				T = p;
			else
				temp->Ribro = p;
			temp = p;
即T为空时，将p赋予T，否则将p赋予T的最右边。
要是我自己来写，那估计就是
			if(!T)
			{
				T = p;
				temp = T;
			}
			else
			{
				while(temp->RN)
					temp = temp->RN;
				temp->RN = p;
			}
或者云云。。。反正上面的更简洁高效。



prim
总结：整体看来，整个函数集中在两个地方：① 初始化closedge,将形参中提供的点到各个点的距离填入closedge中，以便于之后				    的比较和新节点的加入。
				② 选择closedge数组中存在的最短的边 将之作为构成最小生成树的一部分
				③ 加入新的点后，更新closedge中的数据。新加入集合的B点到C点的距离如果小于				    	    原来集合中A到C的距离，则用B到C的距离替换更新。

cruscal
总结：整个函数主要由几个小函数构成：	① sort每一条变			【排序算法可有多种选择】
				② find 两个分量是否会构成回路		【】			
				③ union两个分量			【union可有多种】



 关节点
总结：	 本算法要干什么看应用就可以。
	本算法主要在于四个判断：	① FindArticul函数中判断 if(count<G.vexnum)看根节点是否为关节点，有多个子节点则输出根节点并循环检验其余子节点。
				② DFSArticul函数中判断 min > low[p] 看是否可以通过自己的子节点链接到自己的双亲或祖宗节点。
				③ DFSArticul函数中判断 low[p]>visit_order[v0] 看是否子节点的low大于本节点的遍历顺序，大于则判定自己为关节点。
				④ DFSArticul函数中判断 if(visited) 看是否已被访问，已被访问过则为自己的双亲或祖宗节点，则可以连到这个点，即low = visit_order[p];
				


关键路径
总结：	关键路径是在满足拓扑排序的前提下进行的。
	本程序主要在求两个数组，顶点的ve和vl，然后通过点的ve,vl求得边的ee,el,继而判断是否为关键。
	主要在两个循环里的两个判断	① ToplogicalOrder 函数中while循环的判断 if(ve[p->adjvex] < ve[temp]+(*(p->info))) 求ve数组的方法是：  令ve[p->adjvex] 取较大者。这里的取较大值为零星式比较【(即与a相连的点有b,c,d,我要比的是b,c,d的ve值，而非a的ve值，接下来到点b,相连的点为c,d,要比的是c,d的ve值而非b的ve值)】
				② CriticalPath 函数中 if(vl[temp]  > vl[p->adjvex]-(*(p->info))) 求vl数组的方法：   令vl[temp]取较小值。这里为发散式比较。【(即与a相连的点有b,c,d,要比的就是a的vl值，接下来到点b,相连的点为c,d,要比的就是b的vl值)】
是什么导致求ve，vl的方式不同呢？
	求ve是从首到尾，首的ve为0，继而求相连的点的ve，都是先知道前面然后求后面，重点在求后面
	求vl是从尾到首，尾的vl值是最大值，继而求相连的前驱的vl，都是先知道后面再求前面，重点在前面，当然用广式。



某点最短路径
总结：	本算法是求一个点到所有点的最短路径。
	根据算法描述：，假设S为已求的最短路径的终点的集合，则可证明：下一条最短路径（设其终点为x）一定是弧（v，x），或者是中间只经过S中的顶点而最后到达顶点x的路径。
	算法主要利用到3个数组    ① final[] 数组用于记录是否该顶点已在最短路径集合中(因为点到其余点的最短路径是要建立在集合中的点的基础上的)
			      ② PathMartic &P 二维数组。若P[v][w]为TRUE 则w是从v0到v当前求得最短路径上的点。这个数组是结果数组。
			      ③ ShortPathTable &D 一维数组 用于记录该点到每一个其余点的路径长度。  这个数组和final 数组是整个算法最主要的两个元素 最终构成P这个结果二维数组。从此数组中选出最短的一条，即取得要加入最短路径集合的顶点元素，之后更新此D数组和P数组(因为final数组中新增元素可能导致这个点同过集合中的点到其余点的路径变短(或从INFINY变成实数))，更新玩后，即循环之前步骤。


各点
总结：	理解的挺模糊的，大致可以记得的是一个函数；两个大块；每块都是循环；第一块是二重循环，第二块三重循环；第一块是初始化，第二块是更新路径，碰见短的就更新。
	不理解的话，背起来还是很容易的。  - 。-！
	初始化循环不说。
	更新循环的话最外层k，之后i，最后j	a[i][k]+a[k][j] < a[i][j]	判断此处，为1则更新


无用收集
总结：	本算法主要构成：	利用表节点本身的指针域标记遍历路径的算法。
	理解三个指针t,p,q的用法，外加结构体本身tag的重利用。
	算法和树的中序非递归算法类似。 复习时候可以借助和非递归算法结合。
	一些算法是在几个循环或几个数组上，这个算法主要是套在非递归算法上。备注中也有往这个方向靠。