弗洛伊德(Floyd)算法

这个算法和上面的Dijkstra算法用来求 每一对 顶点之间的最短路径的时间复杂度都为O(n^3)

算法过程：（求vi到vj的最短路径）
① 看是否存在从vi到vj的弧，若有，该弧（路径）也不一定是最短路径
② 首先考虑(vi,v0,vj)是否存在，(即判别(vi,v0)(v0,vj)是否存在)。
③ 如果存在，则比较(vi,vj)和(vi,v0,vj)的路径长度取长度较短者为从vi到vj的中间顶点的序号不大于0的最短路径。
④ 加入在路径上再增加一个顶点v1,也就是说，如果(vi,···,v1)和(v1,···,vj)分别是当前找到的中间顶点的序号不大于零的最短路径，那么(vi,···,v1,···,vj)就有可能是从vi到vj的中间顶点的序号不大于1的最短路径。
⑤ 将它和已经得到的从vi到vj中间顶点序号不大于0的最短路径相比较，从中选出中间顶点的序号不大于1的最短路径之后，再增加一个顶点v2继续进行试探。
⑥ 一般情况下，若(vi,...,vk)和(vk,...,vj)分别是从vi到vk和从vk到vj的中间顶点的序号不大于k-1的最短路径，则将(vi,...,vk,...vj)和已经得到的从vi到vj的中间顶点的序号不大于k的最短路径。
⑦ 在经过n次比较后 最后求得的必是从vi到vj的最短路径。


总结：	理解的挺模糊的，大致可以记得的是一个函数；两个大块；每块都是循环；第一块是二重循环，第二块三重循环；第一块是初始化，第二块是更新路径，碰见短的就更新。
	不理解的话，背起来还是很容易的。  - 。-！
	初始化循环不说。
	更新循环的话最外层k，之后i，最后j	a[i][k]+a[k][j] < a[i][j]	判断此处，为1则更新