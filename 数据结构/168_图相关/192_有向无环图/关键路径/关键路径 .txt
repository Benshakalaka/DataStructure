关键路径：   （此程序为AOE-网）边表示活动
正常情况下，网中只有一个入度为零的点（源点）和一个出度为零的点（汇点）

和AOV-网不同。对AOE-网有待研究的问题是：
① 完成整项工程至少需要多长时间
② 哪些活动是影响工程进度的关键

由于AOE-网中有些活动可以并行，所以完成工程最短时间是从开始点到完成点的最长路径的长度（这里的路径长度是指路径上个活动持续时间之和，不是弧的数目）。路径长度最长的路径叫做关键路径。

假设开始点是v1,从v1到vi的最长路径长度叫做事件vi的最早发生时间。这个时间决定了所有以vi为尾的弧所表示的活动的最早开始时间。
我们用e(i)表示ai的最早开始时间。
    用l(i)表示一个活动的最迟开始时间。（这是在不推迟整个工程完成的前提下，活动ai最迟必须开始的时间）
l(i)-e(i)意味着完成ai的时间余量 
l(i)=e(i)的活动叫做关键活动。（显然，关键路径上的所有活动都是关键活动，因此提前完成非关键活动并不能加快工程的进度）

经分析可知，辨别关键活动就是要找e(i)=l(i）的活动。
为了求得e(i)和l(i),首先要求事件的最早发生时间 ve(j) 和最迟发生时间 vl(j) 。如果活动ai由弧<j,k>表示，其持续时间记为 dut(<j,k>),则有如下关系：
		e(i) = ve(j);
		l(i) = vl(k) - dut(<j,k>)
⑴ 从ve(0)=0开始向前递推
		ve(j)=MAX{ve(i)+dut(<i,j>)}
			<i,j> ∈ T, j=1,2,3,..,n-1
其中，T是所有以第j个顶点为头的弧的集合
⑵ 从vl(n-1)=ve(n-1)起向后递推
		vl(i)=MIN{vl(j)-dut(<i,j>)}
			<i,j> ∈ S，i=n-2,...,0
其中，S是所有以第i个顶点为尾的弧的集合。
这两个计算必须在拓扑有序和逆拓扑有序的前提下进行。

下面整理一下以上算法中各变量的意义：
ai       -----> 一个活动             -----> 由弧<j,k>表示
ei:      -----> 活动i的最早开始      -----> = Ve(j)
li:	 -----> 活动i的最迟开始      -----> = Vl(k)-dut(<j,k>)(事件持续时间)
Ve(j):   -----> 一个事件最早发生时间
Vl(k):   -----> 一个事件最迟发生时间



总结：	关键路径是在满足拓扑排序的前提下进行的。
	本程序主要在求两个数组，顶点的ve和vl，然后通过点的ve,vl求得边的ee,el,继而判断是否为关键。
	主要在两个循环里的两个判断	① ToplogicalOrder 函数中while循环的判断 if(ve[p->adjvex] < ve[temp]+(*(p->info))) 求ve数组的方法是：  令ve[p->adjvex] 取较大者。这里的取较大值为零星式比较【(即与a相连的点有b,c,d,我要比的是b,c,d的ve值，而非a的ve值，接下来到点b,相连的点为c,d,要比的是c,d的ve值而非b的ve值)】
				② CriticalPath 函数中 if(vl[temp]  > vl[p->adjvex]-(*(p->info))) 求vl数组的方法：   令vl[temp]取较小值。这里为发散式比较。【(即与a相连的点有b,c,d,要比的就是a的vl值，接下来到点b,相连的点为c,d,要比的就是b的vl值)】
是什么导致求ve，vl的方式不同呢？
	求ve是从首到尾，首的ve为0，继而求相连的点的ve，都是先知道前面然后求后面，重点在求后面
	求vl是从尾到首，尾的vl值是最大值，继而求相连的前驱的vl，都是先知道后面再求前面，重点在前面，当然用广式。

总结中提到的零星式和发散式是自己随便取名的，其实可以类比于哈夫曼树的两种求编码的方式。一种是从叶子节点开始往上走，类比于这里的发散式，即一下将一个点搞定。另一种是从根节点开始遍历，遍历到谁，就搞谁。。。