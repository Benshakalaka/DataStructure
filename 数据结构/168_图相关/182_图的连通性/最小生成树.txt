要在n个点之间建立联系 总共有(n-1)*n/2条路线 只需要n-1条路线就可以达到目的
这里有两个利用MST性质的关于生成最小生成树的算法
①
普里姆算法
假设N=（V，｛E｝）是连通网，TE是N上最小生成树中边的集合。算法从U=｛u0｝（u0 ∈V），TE=｛｝开始，重复执行以下操作：在所有u∈U，v∈V-U的边（u，v）∈E中找一条代价最小的边（u0，v0）并入集合TE，同时v0并入U，直至U=V为止。此时TE中必有n-1条边，则T=（V,｛TE｝）为N的最小生成树。(具体过程可见图)
(n个顶点)时间复杂度为O（n^2）  
**********************************************适用于求边稠密的网的最小生成树。

总结：整体看来，整个函数集中在两个地方：① 初始化closedge,将形参中提供的点到各个点的距离填入closedge中，以便于之后				    的比较和新节点的加入。
				② 选择closedge数组中存在的最短的边 将之作为构成最小生成树的一部分
				③ 加入新的点后，更新closedge中的数据。新加入集合的B点到C点的距离如果小于				    	    原来集合中A到C的距离，则用B到C的距离替换更新。

②
克鲁斯卡尔算法
假设连通网N=（V，｛E｝），则令最小生成树的初识状态为只有n个顶点而无边的非连同图T=（V，｛｝），图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。以此类推，直至图中所有顶点都在同一个连通分量上为止。（具体过程见图）
（n个顶点）时间复杂度为O（eloge）
此算法相较于Prim算法稍好些
**********************************************适合于求稀疏的网的最小生成树

总结：整个函数主要由几个小函数构成：	① sort每一条变			【排序算法可有多种选择】
				② find 两个分量是否会构成回路		【】			
				③ union两个分量			【union可有多种】