键树（数字查找树）（一棵度 ≥ 2的树）  【什么是度？ 指的是树内各节点的度的最大值(节点拥有的子树数称为几点的度)】

	树中的每个节点中不是包含一个或几个关键字，而是只含有组成关键字的符号。例如，若关键字是数值，则节点中只包含一个数位；若关键字是单词，则节点中只包含一个字母符号


键树的两种存储结构：
	① 以树的孩子兄弟链表来表示键树，每个分支节点包括3个域：【此时键树又叫双链树】
		⑴ symbol域：存储关键字的第一个字符
		⑵ first域：存储指向第一棵子树根的指针
		⑶ next域：存储指向右兄弟的指针
		⑷ 叶子节点的 infoptr 域指向该关键字记录的指针
		树中每个节点的最大度和关键字的‘基’有关；若关键字是单词，则d=27；若为数值，则d=11; 【为什么比是27而不是26？为什么是11而不是10？因为节点的first子节点可能是要用来存叶子的（即信息指针）比如CHA是存在的，现在存CH,总不见得连在H后面吧，所以放在第一个位置】键树的深度h则取决于关键字中字符或数位的个数。假设关键字为随机的（即关键字中每一位取基内任何值的概率相同），则在双链树中查找每一位的平均查找长度为 1/2 *(1+d)。又假设关键字中字符的个数都相等，则在双链树中进行查找的平均查找长度为 h/2*(1+d)。
		在双链树中插入或删除一个关键字，相当于在树中某个节点上插入或删除一棵子树。

		这是棵什么样子的树呢？  非根节点正常；叶子节点里不用first指针而是infoptr指针 ，指向的是另外的地方，所以插入时候遍历时候需要注意。





	② 以树的多重链表表示键树，树的每个节点中应含有d个指针域。【此时键树又叫Trie树】。
		若从键树中某个节点到叶子节点的路径上每个节点都只有一个孩子，则可以将该路径上所有节点压缩成一个“叶子节点”，且在该叶子节点中存储关键字及指向记录的指针信息。
	Trie树也称字典树，因为其效率很高，所以在在字符串查找、前缀匹配等中应用很广泛，其高效率是以空间为代价的。




写较为繁琐的函数时候。
①注意条理清晰
②函数中需要较长代码实现一个功能可以另设一个函数




回顾：
	键树又叫字典树，所以脑海里就对整棵树有了大概的认识。
双链键树：
	看上面的定义内容就知道。这里是用了孩子兄弟方式存储关键字符
	依旧跟之前的一样，查找不难，烦就烦在建立、修改这棵树。
	查找：对根节点进行比较，如果找到相同的，那么继续传递到这个相同字符的first节点。那难道都找完了还要往下找一层first吗？【这里有个要注意的：可先看一下头文件对节点的定义  是将 first和infoptr 放在一起 所以infoptr如果存在的话是要取代first的】所以继续往下一层就相当于找到信息指针了。
	一般这种树是不会删除关键字节点的吧？。。。且不管
	插入呢？
	插入就是主要部分了，因为是动态查找，所以树的创建过程就是不断插入新的节点。
	往常一样‘分为两种先
	树本身不存在	树本身存在
	树不存在，那么每个字符就是一层，且都是放在first位置，直到最后放个叶子节点存储信息指针、
	树已经存在了，【需要插入分两种情况： 一种是所有字符都找到了但信息指针没有找到	一种是字符都没找到最后】
		首先用循环找到精确的需要插入的位置，看关键字是否已经查找完 若已查完，则为第一种情况。插入一个叶子节点放在first位置上
		没查完，则将之后的字符全插进去。
	整个遍历是将所有叶子节点输出，因为输出的是整个关键字，且按顺序输出

Trie树
	这是用多子树来存
	还是树存在和不存在两种情况
	不过这里的不存在的树是直接插入一个叶子节点，如果有新的则将其拆分。
	树本身存在的话，再分情况： 某个需要在其后插入新节点的节点是否为空。
		为空：则直接插入一个叶子节点。
		不为空：则新建节点【记住：某层就代表第某个字符，不可跳跃】 因此可能创建多个节点 用到循环【看新插入的节点和已存在节点有多少相同字符】