二叉排序树

⑴什么是排序二叉树？----------------------------------------
可能是一棵空树。
可能是具有如下性质的二叉树：
①若左子树不空，则左子树上所有节点都小于根节点的值
②若右子树不空，则右子树上所有节点都大于根节点的值
③它的左、右子树也分别为二叉排序树

二叉排序树又称为二叉查找树.查找过程如下:
当二叉树不空时，首先将给定值和根节点的关键字比较，若相等，则查找成功，否则依据给定值和根节点的关键字之间的大小关系，分别在左子树或右子树上继续进行查找。

⑵二叉排序树的插入和删除------------------------------------
二叉排序树是动态树表。
树的结构是在查找过程中，当树中不存在关键字等于给定值的节点时在进行插入。新插入的节点一定是一个新添加的叶子节点，并是查找不成功时查找路径上访问的最后一个节点的左孩子或右孩子节点。
如图中例子，中序遍历该二叉树可以得到一个关键字的有序序列。
二叉排序树即拥有类似折半查找的特性，又采用了链表作结构。
同样，删去一个节点相当于删去有序序列中的一个记录，只要在删去某节点之后依旧保持二叉排序树的特性即可。
删除操作：
分为三种情况。见图。


回顾：
	这算是近来最简单的算法了。
	怎么搜索？ 递归呗，搜不到就看大小往两边走。记得返回个插入的地方。
	怎么插入？借着返回来的插入的地方，看大小插在两边呗。
	怎么删除？嗯，这个总算是有点思考的余地。  删除有两种方法[或者更多] 一种是移花接木，大动干戈[不建议] 另一种是找前驱给填补上。
	那具体点[一看就知道怎么做的那种]  要删的节点如果只有一个孩子，那直接把孩子送到双亲那里去吧。。。
					有两个孩子呢？那就往左孩子[名字叫P]里找前驱[你问我为什么？干！]。找到之后[对，总能找到] 对找到之后的节点进行判定。 如果名字还叫P [shit]，那就表明左孩子是孤身一人，没有孩子，表明前驱就是P，那怎么改知道吧。如果不再是P了[现在叫Q]，那么再判定Q，Q有右孩子吗[为什么不问左孩子？ 去，卖豆腐]，如果有就交给Q的双亲，没有更方便。