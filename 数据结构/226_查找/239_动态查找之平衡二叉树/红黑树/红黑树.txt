http://blog.csdn.net/v_JULY_v/article/category/774945
红黑树
满足以下性质：
	1） 每个节点要么是红的，要么是黑的
	2） 根节点是黑的
	3） 每个叶节点，即空节点（NIL）是黑的
	4） 如果一个节点是红的，那么它的两个儿子都是黑色的
	5） 对每个节点，从该节点到其所有子孙节点的所有路径上包含相同数目的黑节点

以某一节点x为根的子树中至少包含2^(bh(x)) - 1 个内节点。【bh(x)指的是该节点的黑高度】

写完后总结：
        建树主要在于插入和删除
        插入：
       （在插入新节点之前 初始化一个新节点的时候总是将其赋予红色 因为这样尽量不引起红黑树的黑高度的变化） 且 （插入调整主要看叔叔节点 及 当前节点在当前节点的父亲节点的左边还是右边）
      【首先这里讨论的是父亲是祖父的左子节点】+【这里的处理对象是新加入的节点】
        ｛
	case ①： 为根 
	solution： 将节点涂黑

	case ②： 插在黑节点的下面
	solution： 没有限制，无需调整

	case ③： 插在红节点下面 
	               ｛
		         case ⑴： 叔叔节点为红色
		         solution：调整父亲和叔叔颜色都变成黑色　祖父节点变成红色　然后当前要处理的节点指针指向祖父节点
		
		　　　case ⑵： 叔叔为黑
				      ｛
					case ㈠： 当前节点为父亲节点的右子节点
					solution： 当前节点的父节点做为新的当前节点，以新当前节点为支点左旋

					case㈡：  当前节点为父亲节点的左子节点
					solution：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋
				       ｝
		｝
             ｝

	删除：
	（删除节点时候主要考虑节点的兄弟节点以及兄弟节点的两个孩子的颜色）+（理解这里给取代节点赋予双重颜色的含义）+（side的含义，个人觉得这个变量不错）
	【首先这里讨论的是当前节点在双亲节点的左边】+【这里处理的节点是取代被删节点的节点】＋【只被有在被删节点是黑的情况下才讨论】＋【找到了取代被删节点的后继节点】
	 {
		case ①： 为根
		solution： 将根节点涂黑（因为性质要求根为黑）

		case ②：当前节点为红色（所以以下情况当前节点都为黑）
		solution：直接涂黑　弥补被删黑的缺失同时该节点的移动不产生影响

		case　③：兄弟节点为红色
		solution：　把父节点染成红色，把兄弟结点染成黑色，以双亲节点进行左转。（目的：此变换后原红黑树性质5不变，而把问题转化为兄弟节点为黑色的情况）
	
		case　④：兄弟为黑：
			｛
				case Ⅰ：兄弟的两个孩子都为黑
				solution： 把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法【简单的说就是兄弟变红 父亲节点变为当前节点】
				caseⅡ：兄弟节点左孩子红右孩子黑
				solution：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况6，而性质5得以保持
				case Ⅲ：兄弟节点左孩子任意右孩子红
				solution：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋
			｝
	 }