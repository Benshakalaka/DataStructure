//所谓压缩存储： 为多个相同的元只分配一个存储空间；对零元不分配空间
//特殊矩阵：	 相同的元素或者零元在矩阵的分布有一定的规律
//稀疏矩阵：     无规律分布（相反于特殊矩阵）	
//稀疏因子：     &=t/(m*n) 【m*n矩阵中t个元素不为0】 &<=0.05时为稀疏矩阵

①：（转置）
用顺序数组存储矩阵
数据类型：三元组
转置就是原先是行的变成列，原是列的变成行。这个算法通过三元组（即用结构体存储行、列、数值）实现。

主要面临的问题是N的顺序数组里的元素经过M中一个个变换后的行没有按从小到大的顺序排列

步骤
1、先将M中每列（即N中的行）的非零元素用一个数组temp（必须先全部清零）记录（记录N的顺序数组里每行开头非零元素的下标），
2、然后就可以对M中的元素一个个进行访问，按照该数据的j(即第几列)来判断这个数据在N中是第几行数据，
3、从而读出该行开头非零元素的下标，进行存储（当然，存储在N中时i,j需要置换），
4、继而将temp[]代表的该行开头非零元素的下标加一，以便于下一次读入。


②：（相乘）
用顺序数组存储
数据类型：这里比转置时候采用的数据类型多了个元素：上文中提到的temp数组也加入了这个数据类型

相乘主要是算法

当然 m*n 的矩阵和 n*p 的矩阵 得到的矩阵是m*p的（前一个的列必须和后一个的行相等）
步骤
1、已知结果矩阵的行数，一行一行计算进行（大循环开始）
2、将M中某一行的非零元素循环（该行的开头非零元素下标 直到 下一行的开头非零元素下标）（中循环开始）
3、在该循环中，将N中的行等于M中非零元素的j（列下标）的元素循环（该行元素进行循环），与M中的那个元素相乘，(当然，不同的j并不能相叠加，所以这里又创建一个ctemp数组)（小循环开始并且结束）
4、直到M中某行的所有元素循环完毕(中循环结束)，
5、就可以将这个ctemp里存的数据存到结果矩阵中去，如果为0，就不存，跳过。否则，存入结果矩阵。


③：相加
用了链表存储
当然，两个矩阵都是m*n的。

首先创建链表，先弄m+n个指针当作首指针，继而一个个插入（书上的是可以任意插入）

④：过程
这里是以结果矩阵的行循环依据进行的
用M的行的数据依次跟相对应M中的数据的列的N中的行数据相乘，最后一个个相加 然后在给结果矩阵中