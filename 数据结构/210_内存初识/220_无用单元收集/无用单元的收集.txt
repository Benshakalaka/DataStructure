无用单元的收集
① 无用单元
p=malloc(); p=NULL;
分配的节点则成为无用单元 无法得到利用。

② 悬挂访问
p=malloc(); q=p; free(p);
q则成为悬空指针 造成恶劣影响。

如何解决此问题？（广义表为例）
途径①：
使用访问计数器。 在所有子表或广义表上增加一个表头节点，并设立一个“计数域”，它的值为指向该子表或广义表的指针数目。只有当该计数域的值为0，此子表或广义表中节点才被释放。

途径②：
收集无用单元。在程序运行过程中，对所有的链表节点，不管它是否还有用，都不回收，直到整个可利用空间表为空。此时才暂时中断执行程序，将所有当前不被使用的节点连接在一起成为新的可利用表，而后程序才继续执行。可以通过对占用节点的查询，剩下的则是无用的节点。

收集无用单元应分为两步进行：
第一步是对所有占用节点加上标志。
第二部是对整个可利用存储空间顺序扫描一遍，将所有标志域为0的节点连接成一个新的可利用空间表。
以下是三种标志算法(两部操作主要难度集中在标志上)：
①递归算法
②非递归算法
以上都需要一个不确定量的附加存储，均不够理想。
③利用表节点本身的指针域标记遍历路径的算法
	·此算法的目的是： 对所有占用节点加上标志。
	·算法精要：利用表节点本身的指针域标记遍历路径。即利用已经标志过的表节点中的tag,hp,tp 域来代替栈记录遍历过程中的路径。
	·算法大致：当指针p由b移向c(p的hp部分)之前，先将b节点中的hp域值改为指向a，并将b节点中的tag域值改为0；而当指针p由b移向f(p的tp部分)之前，则先将b节点中的tp域的值改为指向a，tag域的值改为1.
	·算法详细：p221

以上3种方法各有利弊。
法③时间消耗多 法②简单但空间消耗大

系统中只有少量节点为无用节点时，收集操作效率很低所以解决的办法可以由系统事先确定一个常数k 当收集到无用单元数为k或更少时系统就不再运行。




总结：	本算法主要构成：	利用表节点本身的指针域标记遍历路径的算法。
	理解三个指针t,p,q的用法，外加结构体本身tag的重利用。
	算法和树的中序非递归算法类似。 复习时候可以借助和非递归算法结合。
	一些算法是在几个循环或几个数组上，这个算法主要是套在非递归算法上。备注中也有往这个方向靠。