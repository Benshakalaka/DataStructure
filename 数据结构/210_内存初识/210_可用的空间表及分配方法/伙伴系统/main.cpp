#include <stdio.h>
#include <math.h>


#define m 16								//16个机器字长  2^16个字 64k   地址从0 ～ 2^m-1	
											//总共有m+1个双向循环链表 第一个代表大小为==2^0=1；第二个代表大小==2^1=2;……最后一个大小==2^16
typedef struct WORD_b			//结构体 惯例整个结构体代表 2^k 大小  但是除内存其他占用一个字的空间
{
	struct WORD_b *llink;		//每个链表都是双重链表  记录左节点
	int tag;					//标志（空闲或占用）
	int kval;					//表示 2^k 中的 k， 即记录幂大小的变量
	struct WORD_b *rlink;		//右节点
	//Other other;
}WORD_b,head;
typedef struct HeadNode			//整个链表数组
{
	int nodesize;				//某个链表中的节点所存的大小（每条链表中的不同空闲节点所存大小都是相同的  链表avail[k]中的节点大小都是 2^k 空闲的内存块）
	WORD_b *first;				//第一个可用来分配的空闲节点
}FreeList[m+1];					//因为机器字长往往不容易改变 所以用定长数组



//分配算法
//当用户提出大小为n的内存请求时，首先在利用表上寻找大小与n相匹配的子表，若此子表非空，则直接将表中任意节点分配即可。
//若为空，则从节点更大的非空子表去查找，直到找到一个空闲块 则将其中一部分分配给用户 将剩余部分分解插入相应子表。
WORD_b * AllocBuddy(FreeList &avail,int n)
{
	int i,j;
	for(i=0;i<=m;i++)
		if(avail[i].nodesize>=n+1 && avail[i].first)		//这里为什么要n+1呢  我也不是很清楚 可能是因为空闲块的大小有1个字节被存储的东西占掉了
			break;

	WORD_b *temp_1,*temp_2,*pre,*nex;
	
	if(i>m)												//没找到符合用户需求的空闲内存块
		return NULL;
	else												//找到后分配
	{
		temp_1 = avail[i].first;							//将temp_1指向这个空闲块
		//为方便 将空闲块的previous 和 next节点拿出来
		pre = temp_1->llink;				
		nex = temp_1->rlink;
		//拿出这个空闲块
		if(pre==nex)								//该链表只有一个节点
			avail[i].first = NULL;
		else										//不止一个则会导致指针的变化
		{
			//相当于删掉一个点
			pre->rlink = nex;	
			nex->llink = pre;
			avail[i].first = nex;
		}
		//如果选取了较大的空闲块  则需要将其瓦解并分发以便于以后的内存分配
		//这个for循环较为重要
		for(j=1;avail[i-j].nodesize>=n+1;j++)
		//为什么是这样子循环呢（对循环内容解释）？
		//①：（解释第二+第五行） 为什么是直接插在链表first？该链表有其他节点就不管了？  因为如果我们需要2^3的内存大小 但现在只有2^2的和2^6的链表有节点（存在空闲块） 只能从2^6身上割下2^3 ， 并且剩下的再分割至各个链表 正好存在式子 2^6 = 2^3 + 2^3 + 2^4 + 2^5(来源于 2^n = 2^(n-1) + 2^(n-1) = 2* 2^(n-1)); 所以要分配的拿走后 正好给从分配大小的链表(2^3)一直到2^6前一个链表(2^5)一一分配一个节点  回到问题如果该链表有节点就不管了？ 想管也没的管啊 大小是从2^3开始分配的 本身需求就是2^3  然后查到2^6才有节点 这一段当然都是空的所以可以直接插在first上
		//②：（解释第一行） 为什么要分解的内容是从 temp_1+(int)pow(2,i-j) 开始？  因为将一个由2^3(即8)个格子组成的东西分成2，2，4这三份；如何从后面开始分呢 ？起点为1 首先从起点加4将下标为5这个格子和之后3的分掉 再从起点加2将下标为3和之后的1个格子分掉 剩下的就是分配出去的（这个为2^n时貌似可以 用到别地就有问题。。。比如6分成1，2，3）
		//③：（解释判条件） 为什么用大小比较的方法进行判断  因为我们选取较大的内存块时并不知道要分配多少，多少会留下分割给其他链表   所以用这个比较作为依据  分到最后根据解释①就是要将最后的一个给【分配大小(①中的2^3)】的链表
		//④： 正好大小不需要分割的呢？ 正好大小的就不会经历循环了 因为avail[i] == n+1；  avail[i-1]绝对小于不符合循环条件
		{
			temp_2 = temp_1+(int)pow(2,i-j);		//第一行
			temp_2->llink = temp_2->rlink = temp_2; //第二行
			temp_2->kval = i-j;						//第三行
			temp_2->tag = 0;						//第四行
			avail[i-j].first = temp_2;				//第五行
		}
		temp_1->tag = 1;
		temp_1->kval = i-j;
	}
	return temp_1;
}

int main()
{
	return 0;
}

