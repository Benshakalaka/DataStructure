回溯法在本书中并未详细讲解  需要另寻算法书学习。

回溯法是设计递归过程的一种重要方法 求解过程实质上是先序遍历一颗 状态树 的过程，只是这棵树不是遍历钱预先建立的 而是隐含在遍历过程中。
回溯法可以解决八皇后问题
回溯法是一个既带有系统性又带有跳跃性的的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。

回溯法的基本思想：确定了解空间的组织结构后，回溯法就从开始结点（根结点）出发，以深度优先的方式搜索整个解空间。这个开始结点就成为一个活结点，同时也成为当前的扩展结点。在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为一个新的活结点，并成为当前扩展结点。如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点。换句话说，这个结点不再是一个活结点。此时，应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。回溯法即以这种工作方式递归地在解空间中搜索，直至找到所要求的解或解空间中已没有活结点时为止。
运用回溯法解题通常包含以下三个步骤：
（1）针对所给问题，定义问题的解空间；
（2）确定易于搜索的解空间结构；
（3）以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索；


下面是我觉得网上比较好的
回溯法
 
    回 溯法也称为试探法，该方法首先暂时放弃关于问题规模大小的限制，并将问题的候选解按某种顺序逐一枚举和检验。当发现当前候选解不可能是解时，就选择下一个 候选解；倘若当前候选解除了还不满足问题规模要求外，满足所有其他要求时，继续扩大当前候选解的规模，并继续试探。如果当前候选解满足包括问题规模在内的 所有要求时，该候选解就是问题的一个解。在回溯法中，放弃当前候选解，寻找下一个候选解的过程称为回溯。扩大当前候选解的规模，以继续试探的过程称为向前 试探。 

    回溯法的一般流程和技术 

    在用回溯法求解有关问题的过程中，一般是一边建树，一边遍历该树。在回溯法中我们一般采用非递归方法。下面，我们给出回溯法的非递归算法的一般流程： 

    在用回溯法求解问题，也即在遍历状态空间树的过程中，如果采用非递归方法，则我们一般要用到栈的数据结构。这时，不仅可以用栈来表示正在遍历的树的结点，而且可以很方便地表示建立孩子结点和回溯过程。
 
    【问题】 组合问题 

    问题描述：找出从自然数1，2，…，n中任取r个数的所有组合。 

    采用回溯法找问题的解，将找到的组合以从小到大顺序存于a[0]，a[1]，…，a[r-1]中，组合的元素满足以下性质： 

    (1) a[i+1]>a[i]，后一个数字比前一个大； 

    (2) a[i]-i<=n-r+1。 

    按回溯法的思想，找解过程可以叙述如下： 

    首 先放弃组合数个数为r的条件，候选组合从只有一个数字1开始。因该候选解满足除问题规模之外的全部条件，扩大其规模，并使其满足上述条件（1），候选组合 改为1，2。继续这一过程，得到候选组合1，2，3。该候选解满足包括问题规模在内的全部条件，因而是一个解。在该解的基础上，选下一个候选解，因 a[2]上的3调整为4，以及以后调整为5都满足问题的全部要求，得到解1，2，4和1，2，5。由于对5不能再作调整，就要从a[2]回溯到a[1]， 这时，a[1]=2，可以调整为3，并向前试探，得到解1，3，4。重复上述向前试探和向后回溯，直至要从a[0]再回溯时，说明已经找完问题的全部解。 按上述思想写成程序如下：
 
    【程序】 

# define MAXN 100 

int a[MAXN]; 

void comb(int m,int r) 

{ int i,j; 

  i=0; 

  a[i]=1; 

  do { 

       if (a[i]-i<=m-r+1 

       { if (i==r-1) 

         { for (j=0;j<r;j++)  printf(“%4d”,a[j]); 

           printf(“/n”); 

          } 

         a[i]++; 

         continue; 

        } 

       else 

       { if (i==0) return; 

         a[--i]++; 

        } 

       } while (1) 

  } 

main() 

{ comb(5,3); 

  } 

    【问题】 填字游戏 

    问题描述：在3×3个方格的方阵中要填入数字1到N（N≥10）内的某9个数字，每个方格填一个整数，似的所有相邻两个方格内的两个整数之和为质数。试求出所有满足这个要求的各种数字填法。
 
    可 用试探发找到问题的解，即从第一个方格开始，为当前方格寻找一个合理的整数填入，并在当前位置正确填入后，为下一方格寻找可填入的合理整数。如不能为当前 方格找到一个合理的可填证书，就要回退到前一方格，调整前一方格的填入数。当第九个方格也填入合理的整数后，就找到了一个解，将该解输出，并调整第九个的 填入的整数，寻找下一个解。
 
    为 找到一个满足要求的9个数的填法，从还未填一个数开始，按某种顺序（如从小到大的顺序）每次在当前位置填入一个整数，然后检查当前填入的整数是否能满足要 求。在满足要求的情况下，继续用同样的方法为下一方格填入整数。如果最近填入的整数不能满足要求，就改变填入的整数。如对当前方格试尽所有可能的整数，都 不能满足要求，就得回退到前一方格，并调整前一方格填入的整数。如此重复执行扩展、检查或调整、检查，直到找到一个满足问题要求的解，将解输出。
 
    回溯法找一个解的算法： 

{ int m=0,ok=1; 

  int n=8; 

  do { if (ok) 扩展; 

       else 调整; 

       ok=检查前m个整数填放的合理性; 

      } while ((!ok||m!=n)&&(m!=0)) 

  if (m!=0) 输出解; 

  else 输出无解报告; 

  } 

    如果程序要找全部解，则在将找到的解输出后，应继续调整最后位置上填放的整数，试图去找下一个解。 



相应的算法如下： 

    回溯法找全部解的算法： 

{ int m=0,ok=1; 

  int n=8; 

  do { if (ok) 

       { if (m==n) 

         { 输出解; 

           调整; 

          } 

         else 扩展; 

        } 

       else 调整; 

       ok=检查前m个整数填放的合理性; 

      } while (m!=0); 

  } 

    为 了确保程序能够终止，调整时必须保证曾被放弃过的填数序列不会再次实验，即要求按某种有许模型生成填数序列。给解的候选者设定一个被检验的顺序，按这个顺 序逐一形成候选者并检验。从小到大或从大到小，都是可以采用的方法。如扩展时，先在新位置填入整数1，调整时，找当前候选解中下一个还未被使用过的整数。 将上述扩展、调整、检验都编写成程序，细节见以下找全部解的程序。
 
    【程序】 

# include <stdio.h> 

# define N 12 

void write(int a[ ]) 

{ int i,j; 

  for (i=0;i<3;i++) 

  { for (j=0;j<3;j++) printf(“%3d”,a[3*i+j]); 

    printf(“/n”); 

   } 

  scanf(“%*c”); 

  } 

  

int b[N+1]; 

int a[10]; 

int isprime(int m) 

{ int i; 

  int primes[ ]={2,3,5,7,11,17,19,23,29,-1}; 

  if (m==1||m%2=0) return 0; 

  for (i=0;primes[i]>0;i++) 

  if (m==primes[i]) return 1; 

  for (i=3;i*i<=m;) 

  { if (m%i==0) return 0; 

    i+=2; 

   } 

  return 1; 

  } 

  

int checkmatrix[][3]={ {-1},{0,-1},{1,-1},{0,-1},{1,3,-1}, 

{2,4,-1},{3,-1},{4,6,-1},{5,7,-1}}; 

int selectnum(int start) 

{ int j; 

  for (j=start;j<=N;j++) 

  if (b[j]) return j; 

  return 0; 

  } 

  

int check(int pos) 

{ int i,j; 

  if (pos<0) return 0; 

  for (i=0;(j=checkmatrix[pos][i])>=0;i++) 

      if (!isprime(a[pos]+a[j]) return 0; 

  return 1; 

  } 

  

int extend(int pos) 

{ a[++pos]=selectnum(1); 

  b[a][pos]]=0; 

  return pos; 

  } 

  

int change(int pos) 

{ int j; 

  while (pos>=0&&(j=selectnum(a[pos]+1))==0) 

  b[a[pos--]]=1; 

  if (pos<0) return –1; 

  b[a[pos]]=1; 

  a[pos]=j; 

  b[j]=0; 

  return pos; 

  } 

  

void find() 

{ int ok=0,pos=0; 

  a[pos]=1; 

  b[a[pos]]=0; 

  do { if (ok) 

          if (pos==8) 

          { write(a); 

            pos=change(pos); 

           } 

          else 

            pos=extend(pos); 

       else 

          pos=change(pos); 

       ok=check(pos); 

      } while (pos>=0) 

  } 

  

void main() 

{ int i; 

  for (i=1;i<=N;i++) b[i]=1; 

  find(); 

  } 

