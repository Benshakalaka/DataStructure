给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)

树的路径长度：从树根到每一个节点的路径长度之和。
节点的带权路径长度：从该节点到树根之间的路径长度与节点上权的乘积。

赫夫曼树算法：
①：根据给定的n个权值｛W1,W2,...,Wn｝构成n棵二叉树集合F={T1,T2,...,Tn}，其中每棵二叉树Ti中只有一个带权为Wi的根节点，其左右子树均空。
②：在F中选取两棵根节点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根节点的权值为其左、右子树上根节点的权值之和。
③：在F中删除这两棵树，同时将新得到的二叉树加入F中。
④：重复②、③，直到F只含有一棵树为止。这就是赫夫曼树

一些总结：
①
在哈夫曼编码过程中，首先先建立哈夫曼树，然后进行编码工作。  这里面涉及到一种遍历的方式（类似编码的第二种方式），在存储方式为孩子双亲二叉树的遍历算法中，可以通过设立一个变量有3中可能，分别 0，1，2。    0意味着往左，1意味着往右，2意味着此节点为根的树已经访问完毕。
②
越来越发现一个函数的实现基于两方面，首先就是算法的提出，继而才是算法的实现。算法的提出可能就是从某个点出发，接着发散，从而完成整个过程。  如这里编码的第二种方式考虑的三种情况0，1，2 ；再如平衡二叉树中的平衡因子可能值，可能情况从而有了整个算法。  所以在创造或是回忆算法时候，注意分情况，不同情况不同实现，说不定整个算法就跃然纸上。