为什么从 0 开始？

最优二叉搜索树
	设 S=｛x1，x2 ··· ，xn｝
	每个节点中的元素 x 大于其左子树中任意节点，小于右子树中的任意节点中元素。
	二叉搜索树叶子节点是形如（x[i]，x[i+1]）的开区间。
	在S的二叉搜索树搜索一个元素x，返回的结果有两种情况：
		① 在搜索树中找到 x = xi；
		② 在搜索树中的叶节点中确定 x ∈ （x[i]，x[i+1]）。

	设在第 ① 种情况中找到元素 x=xi 的概率为bi；
	   在第 ② 种情况中确定 x ∈ （x[i]，x[i+1]）的概率为 ai。 【这里约定x0 = -∞ ，x[n+1] = +∞】这样就存在：
		ai>=0，0<=i<=n；bj>=0，1<=j<=n；∑ai + ∑bj = 1 [(0<=i<=n ，1<=j<=n)]；称为集合S的存取概率分布。
	
	在表示S的二叉搜索树T中，设存储元素 xi 的节点深度为 ci ；叶子节点(x[i]，x[i+1]) 的节点深度为 dj，则：
		p = ∑[bi*ci] + ∑[aj*dj] 
		表示在二叉搜索树T中作一次搜索的平均比较次数。p又称为二叉搜索树的平均路长。
	【注：理解上面两处公式并不难。只要将此树假象为只有一个元素。那么 ∑ai + ∑bj = 1 就意味着该元素在第一中情况的概率加上在第二种情况的概率之和，因为要么为第一种要么第二种，所以概率相加为1  ； 此时p = ∑[bi*(1+ci)] + ∑[aj*dj]  因为ai和bi是不同时存在的，即一个不为0，另一个一定为0，所以概率乘以相应的深度。】

	而最优二叉搜索树就是在所有有序集S的二叉搜索树中找出一棵具有最小平均路长的二叉搜索树。



回顾：
	挖槽，穷举？滚粗。  贪心？貌似是我贪心了，这个挺复杂的样子。 动态规划？[去吧，皮卡丘]
	乍一看，这个函数参数太特么多了。[特么说什么大实话]。
	不过，整个过程用动态规划的思想去看的话很清晰，明了，其实和矩阵连乘那个差不多【好像自己对矩阵连乘比较了解一点 - 。-】。
	首先要了解所有参数的意义： a是节点【找得到的数】 b是叶子【找不到的数】 w是一段的概率之和【为什么需要？因为在选取最佳的过程中类似穷举的方式必不可少】 e是搜索期望【这个是啥？自己去cpp里看】
	其次，一些小细节要注意 比如w和e的行列对于0号元素的是否使用。为什么行或列用的到0？因为你看，如果整棵树只有1个节点，两个叶子   那么就需要有w[0][1] 这个元素用来存[存成w[1][0]这个吊样也是可以理解的嘛]，那w[0][0]呢？完全没有这个叶子节点啊 喂 所以说5个点6个叶子的树中还会出现 w[5][6] 而没有存在 w[6][6]的必要。
	接着明白这些了，就开始动态规划了！
	初始化嘛 ，谁都懂。
	通过w，在[i, j ]之间对e进行选择，谁最小就娶谁。然后默默记下她的下标。
	好了，不胡扯，这个程序主要在两点：
			① 有动态规划的想法后，有最佳子解的认知。 比如，整个问题突然就缩小了，从 i 到 j ，无论我取[i,j]之间哪两个，两边都是最优的，那我就要选一个，得到最最优的[举个例子，有3个儿子，1个是幼儿园第一，1个是初中第一，1个是高中第一，尽管都是最优，但仍能选出更优] 这里就可以进行短暂而痛苦的穷举了。
			② 对一个式子有一定了解，就是怎么选最优的呢？e[i][j] = e[i][k-1] + e[k+1][j] + w[i][j] 对就是这个 [问我怎么来的？我去，你看的是题目还是我？]