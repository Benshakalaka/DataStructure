#include <stdio.h>
#include <malloc.h>

struct Goods
{
	int weight;
	int value;
};

void FormMatrix(int n,int m,Goods *things,int **c)
//m为总质量、n为可选种类、things为具体属性、c[i][j]记录总质量为j有i种可选情况下的最优解
//主要是理解构造出来的矩阵，与上一个矩阵连乘的题目相类似。都是构造一个数据矩阵，最后通过矩阵得到最终解决方案。
{
	int i,j;
	//下面是给0情况赋初值，重量为0下装1个物品的情况和装n个东西的情况一样，最终价值总和都为0
	//					   0个可选在重量无限制的情况下最终总价值都为0
	//为什么要这个0呢？	相当于初始化整个情景【在没包时，在没重量时】，为整个过程的开始做好准备。不然突然就问是否能装1，却不知道包初识情况，突兀。
	for(i=0;i<=m;i++)		
		c[0][i] = 0;
	for(i=0;i<=n;i++)
		c[i][0] = 0;
	int temp;
	//下面是以有几种包可选作为大前提，继而看在不同重量限制下如何得到最优解。
	//那为什么不直接在重量为m【定值】的时候在i【变量】种可选中挑选最优呢？    
	//因为这就是动态规划的特色---------------------------------------------最优解中亦包含最优子解。
	//例如：	一定计算后，【a种可选，总质量为b的最优解为BV】，问是否要装接下来的质量为m价值为v的东西：如果不装，那最优依旧是原来的BV，a=a+1 ,且不用管质量是否超出；如果装，那本物品质量必须算进去【即总质量不能超，现在可分配质量为b-m】，必须在b-m中得到最优解，然后加上本物品的价值v,看哪种情况价值高
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
		{
			c[i][j] = c[i-1][j];
			if(j>=things[i].weight)				// 必须是大于等于而不仅仅是大于，因为若总质量为5，有质量4和5两种可选择，若5价值高定选5，此刻就等于最大容量
			{
				temp = c[i-1][j-things[i].weight]+things[i].value;
				if(c[i][j] < temp)				//装与不装的情况进行比较
					c[i][j] = temp;
			}
		}
}

void FindSolution(int n,int m,Goods *things,int **c,int *&x)
//将是否装入记入数组x	1为装入、0为不
{
	int i;
	for(i=n;i>=1;i--)
	{
		if(m>=0 && c[i][m] > c[i-1][m])			//若在总质量为m、有n种可选情况下的价值和n-1中可选的价值不同，肯定是将第n中加入了，否则价值不会变
		{
			x[i] = 1;
			m = m-things[i].weight;				//既然装入了，就要考虑m-things[i].weight中的最优解 将其记录
		}
	}
	for(i=1;i<=n;i++)
		printf("%-5d",i);
	puts("");
	for(i=1;i<=n;i++)
		printf("%-5d",x[i]);
	puts("");
}

int main()
{
	int **c;
	int m,n;
	scanf("%d%d",&n,&m);
	c = (int **)malloc(sizeof(int*)*(n+1));				//从 0,1,2...n
	int i;
	for(i=0;i<=n;i++)
		c[i] = (int*)malloc(sizeof(int)*(m+1));			//从 0,1,2...,m
	/*Goods things[] = {									//0号不用    3 10
		{0,0},{5,6},
		{4,5},{3,4}
	};*/
	Goods things[] = {									//0号不用 8 200
		{0,0},{79,83},
		{58,14},{86,54},
		{11,79},{28,72},
		{62,52},{15,48},
		{68,62}
	};
	FormMatrix(n,m,things,c);
	for(i=0;i<=n;i++)
		for(int j=0;j<=m;j++)
			printf("%d%c",c[i][j],(j+1)%(m+1)==0?'\n':' ');
	puts("");
	int *x = (int *)malloc(sizeof(int)*(n+1));
	for(i=0;i<=n;i++)
		x[i] = 0;
	FindSolution(n,m,things,c,x);
	
	return 0;
}


//之所以用矩阵记录，是动态规划的特色。本来看到题目最先想到的就是穷举法，利用动态规划就可以更简洁些。
//然而动态规划的优点就是要在计算过程中将结果记录，在求更大的结果的时候可以用到较小的记录的值，从而简化整个思路以及计算过程。
//比如，100大小的背包要装10种东西，各自有重量和其价值。如果我知道9种可选在1-100大小情况下的最优解，那就只需要判断要不要装这第10种东西了 ，就成了0-1问题